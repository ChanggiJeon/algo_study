# 우선 나열해보자

# 1
# 1:1
# 2:null
# 3:null

# 2
# 1:null
# 2:2
# 3:null

# 3
# 1:1+2
# 2:2+1
# 3:3

# 여기까지는 Default 값일 거다

# 4
# 1:1+2+1 ,1+3
# 2:null
# 3:3+1

# 4가 최초로 점화식이 적용되는 구간 일텐데 언뜻봐서 모르겠다 공통점을 찾아보자
# 1이 추가된 영역에서 앞의 1을 제거해보자 2+1 ,3 이 남는다
# 나온 요소들이 포함되는 위치는 3의 위치 리스트로 분류하면 현재 포인트를 a로 가정했을때
# List[a-1]지점이다.
# 2가 추가된 영역은 존재하지 않으므로 아직 확신을 가질 수 없다.
# 3이 추가된 영역은 1이 남게된다.
# List[a-3]지점이다.

# 아직 확신하기는 이르다. 5를 확인해보자
# 5 
# 1: 1+3+1
# 2: 2+1+2, 2+3
# 3: 3+2

# 1이 추가된 영역은 3+1 해당 요소를 가지고 있는 지점은 List[a-1]인 4밖에 없다.
# 2가 추가된 영역은 1+2, 3을 가지고 있고 해당요소를 가지고 있는 지점은 List[a-2]지점인 3밖에 없다.
# 3이 추가된 영역은 2 해당요소를 가지고 있는 지점은 List[a-3]인 2밖에 없다.
# 여기서에서 추론할 수 있는 결론은 max값 3을 한계로 각 추가되는 숫자의 크기 비례하듯 감소한 위치의 인덱스 요소만 포함한다.
# 그렇다면 추가로 드는 의문 왜 모든 요소를 포함하지 않는가?
# 현재로는 추측할 근거가 부족함으로 다음 숫자를 분석해보자

# 6
# 1: 1+2+1+2, 1+2+3,1+3+2
# 2: 2+1+2+1, 2+1+3, 2+3+1
# 3: 3+1+2, 3+2+1

# 1이 추가된 영역은 2+1+2, 2+3, 3+2 해당 요소를 가지고 있는 지점은 List[a-1]인 5밖에 없다.
# 2가 추가된 영역은 1+2+1, 1+3, 3+1 해당 요소를 가지고 있는 지점은 List[a-2]인 4밖에 없다.
# 3이 추가된 영역은 1+2, 2+1 해당 요소를 가지고 있는 지점은 List[a-3]인 3밖에 없다.
# 앞서 낸 결론인 max값 3을 한계로 각 추가되는 숫자의 크기 비례하듯 감소한 위치의 인덱스 요소만 포함한다. 확정 지어도 될것 같다.
# 이제 데이터 폭이 넓어졌으니 각 인덱스 지점에서 어떤 요인이 제외됬는지 분석해보자
# 1이 추가된 영역은 각 2가 추가된 영역과 3이 추가된 영역이 도출된다. 추가된 요소를 인덱스로 구분하면 1과 2의 지점이다.
# 2가 추가된 영역은 각 1이 추가된 영역과 3이 추가된 영역이 도출된다. 추가된 요소를 인덱스로 구분하면 0과 2의 지점이다.
# 3이 추가된 영역은 각 1이 추가된 영역과 2가 추가된 영역이 도출된다. 추가된 요소를 인덱스로 구분하면 0과 1의 지점이다.
# 위의 결과로 도출되는 결론은 
# 1~3의 구간을 제외하고 추가되는 영역은
# 1일때 List[a-1][1],List[a-1][2]가 추가되고
# 2일떄 List[a-2][0],List[a-2][2]가 추가되고
# 3일때 List[a-3][0],List[a-3][1]가 추가된다.
# 라고 할 수 있다.

# 그럼 이전에 나온 수로 증명해보자 
# 5의 경우 
# 1일때 4의 [1]의 요소인 null과 [2]의 요소인 3+1 추가되어 3+1 가진다(참)
# 2일때 3의 [0]의 요소인 1+2와 [2]의 요소인 3 이 추가되어 1+2,3을 가진다(참)
# 3일때 2의 [0]의 요소인 null과 [1]의 요소인 2 가 추가되어 2를 가진다(참)
# 이로써 각 경우의 수는 List[a]= (List[a-1][1]+List[a-1][2])+(List[a-2][0]+List[a-2][2])+(List[a-3][0]+List[a-3][1])이지만
# 각 경우마다 사용하기 위해 []형식으로 표현하자 
# List[a] = [List[a-1][1]+List[a-1][2],List[a-2][0]+List[a-2][2],List[a-3][0]+List[a-3][1]]

N = int(input())
M = [int(input()) for _ in range(N)]
DP = [0]* 100001
DP[1] = [1,0,0]
DP[2] = [0,1,0]
DP[3] = [1,1,1]
for i in range(4,max(M)+1):
    DP[i] = [(DP[i-1][1]+DP[i-1][2])%1000000009,(DP[i-2][0]+DP[i-2][2])%1000000009,(DP[i-3][0]+DP[i-3][1])%1000000009]
for j in M:
    print(sum(DP[j])%1000000009)

# 아 화가 난다. 인자들 합에서 1000000009를 나누래서 합에만 나눴더니 시간초과 뜬다.
# 그래서 각 인자별 1000000009를 나누니 정답...