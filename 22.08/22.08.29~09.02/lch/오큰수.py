N = int(input())
base = list(map(int, input().split()))

ans = [-1 for _ in range(N)]
stack = []
# 구해야 하는수 : 오른쪽에있으면서 자신보다 큰수중 가장왼쪽
# 왼쪽에서 오른쪽으로 훝으면서 본인보다 큰수가 나오면 바로 출력하는식

# N이 1,000,000 까지 가기 때문에 한번에 끝내야 한다

for i in range(N-1):
    # 다음수가 자신보다 크다면 바로 출력
    if base[i] < base[i+1]:
        ans[i] = base[i+1]
    # 기준은 오른쪽이기 때문에 왼쪽에 있는 숫자들은 오큰수를 입력하지 않은 숫자만 기억한다
    # 다음숫자가 자신보다 작거나 같으면 저장한 후에 이 숫자보다 크다면 오큰수 입력?
    # 그런데 빈곳이 어딘지는 어찌 기억하지?
    # 일단 해볼까
    # 순서 잡기
    #1. 다음수와비교후 더큰수라면 입력 없으면 스택에 입력
    #1-1. 더 큰수가 나왔다면 스택과 비교해서 지난 수도 입력후 pop하기
    #1-1-1. 지나간 숫자를 입력했다면 한번더 반복하여 그전것도 채우기
    #1-1-2 지나간숫자는 끝났다면 다음단계로
    #1-2. 더 작은수라면 끝내고 다음수로 넘어간다

    else:
        stack.append([i, base[i]])

    if stack:
        for j in range(len(stack)):
            if base[i + 1] > stack[-1][1]:
                ans[stack[-1][0]] = base[i + 1]
                stack.pop()
            else:
                break

print(*ans)

# 일단 채점이 1%에 2초씩 걸림