# DP는 점화식을 도출해 내는 것이 가장 중요하다!
# 키포인트 : 이 문제에서는 n의 값에 따라 규칙을 찾아보는 것까지는 생각하기 쉽지만 끝자리 수까지 고려하여 2차원 배열로 규칙을 찾아내는 부분이 생각해내기 어려웠다.
# 쉬운 계단 수 = 숫자의 길이(행) 끝자리 수(열)의 2차원 배열로 점화식을 찾는다. -> 이거만 알면 풀 수 있다.(이걸 어떻게 생각해내지...)
# -> 점화식 : dp[i][j] = dp[i−1][j−1]+dp[i−1][j+1]
n = int(input())
# 열 = 끝자리 숫자 0~9를 의미 / 행 = 숫자의 길이(0을 제외하기 위해 + 1)
dp = list([0] * 10 for _ in range(n + 1))
# 길이가 1일 때 초기값 설정 -> 여기서 2일때, 3일때까지 손으로 직접 계산해보면 점화식이 나온다.
dp[1] = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1]

for i in range(2, n + 1):
    # 끝자리가 0인 경우와 9인 경우(양끝)은 대각선 위가 한쪽밖에 없음으로 따로 계산한다.
    dp[i][0] = dp[i - 1][1]
    dp[i][9] = dp[i - 1][8]
    # 1~8까지 점화식에 따라 계산
    for j in range(1, 9):
        dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]

# 길이가 n인 계단수의 총 합 = dp의 n번째 줄의 합 (& 1,000,000,000으로 나눈 나머지)
print(sum(dp[n]) % 1000000000)