# 처음보는 유형의 문제였다. 전체를 탐색하면 4000 ** 4만큼의 경우의 수가 나올 것이기에 반드시 시간초과가 날 것이다.
# 참고 : https://velog.io/@ckstn0778/%EB%B0%B1%EC%A4%80-7453%EB%B2%88-%ED%95%A9%EC%9D%B4-0%EC%9D%B8-%EB%84%A4-%EC%A0%95%EC%88%98-X-1
# 키포인트1 : 네 수의 합을 둘둘로 나눠서 두 리스트에서 나올 수 있는 합의 경우의 수를 모두 새 리스트에 담는다.(4000 * 4000 2개)
# => 이렇게 되면 네개의 리스트를 각각 하나씩 비교하는 것이 아닌 두 리스트에서 뽑은 두 수의 합이 0이 되는 경우만 찾으면 됨으로 훨씬 효율적이다.
# 키포인트2 : 만들어진 두 리스트를 비교하는 방식 -> 정렬 + 투포인터 방식을 적용하여 합이 0이 되는 경우를 찾아낸다.
# => 정렬한 후에 한 리스트는 시작점부터, 다른 리스트는 끝점부터 포인터(인덱스)를 옮겨가며 합을 비교하는 방식이다.
# => 정렬되어 있기 때문에 지나간 숫자는 다시 고려할 필요가 없어 효율적인 연산이 가능하다.
# => 합의 결과가 음수이면 시작점을 한칸 옮기고(음수의 절대값을 줄이고) 양수이면 끝점을 한칸 옮긴다(양수의 절대값을 줄인다).

n = int(input())
arr = [list(map(int, input().split())) for _ in range(n)]
ab, cd = [], []
for i in range(n):
    for j in range(n):
        # A와 B에서 나올 수 있는 모든 합의 경우의 수 리스트
        ab.append(arr[i][0] + arr[j][1])
        # C와 D에서 나올 수 있는 모든 합의 경우의 수 리스트
        cd.append(arr[i][2] + arr[j][3])
# 정렬
ab.sort()
cd.sort()
# i는 ab의 시작점 / j는 cd의 끝점
i, j = 0, len(cd) - 1
result = 0
# i와 j가 탐색 가능한 범위안에 있을 때 무한 반복
while i < len(ab) and j >= 0:
    # 두 수의 합이 0인 경우 : 기본적으로 result를 +1하면 된다고 생각할 수 있지만,
    # 키포인트3 : 순열처럼 같은 값이라도 다른 수로 보기 때문에 연속된 같은 수에서 나올 수 있는 경우의 수를 모두 고려해주어야 한다.
    if ab[i] + cd[j] == 0:
        nexti = i + 1
        nextj = j - 1
        # 다음 수가 범위안에 있고(인덱스 에러 방지) 같은 수이면 계속 체크
        while nexti < len(ab) and ab[i] == ab[nexti]:
            nexti += 1
        while nextj >= 0 and cd[j] == cd[nextj]:
            nextj -= 1
        # 같은 수의 경우의 수 계산 후 더하기
        result += (nexti - i) * (j - nextj) # j는 nextj보다 크다.
        # 위에서 while문이 정지함 = 같은 수가 아님 -> 여기부터 다시 돌리면 됨
        i, j = nexti, nextj
    # 합이 음수면 ab의 값을 증가시킨다.(왜냐하면 정렬&투포인터 방식으로 인해 ab는 증가, cd는 감소만 하기 때문)
    elif ab[i] + cd[j] < 0:
        i += 1
    # 합이 양수면 cd의 값을 갑소시킨다.
    else:
        j -= 1

print(result)